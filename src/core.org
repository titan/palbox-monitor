* 基本框架

Box monitor 用于检查 box 设备的上线情况，遇到设备掉线的情况，要及时发送邮件进行通告。

Box monitor 从缓存中获取到已开通的 box 设备，并与当前活动设备进行比较，如果发现
有未上线的设备就通过邮件通报。已开通的 box 设备保存在缓存中的 box.registered 集
合下。当前活动设备保存在 box.activated.YYYY-mm-DD.HH.MM 下。

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-monitor/src/box_monitor.nim
  import asyncdispatch, logging, redis, sequtils, sets, smtp, strfmt, strutils, times

  let to = @["howay.tan@fengchaohuzhu.com", "arming.huang@fengchaohuzhu.com"]

  <<sendmail>>

#+end_src

** serve

程序的难点在于如何判断设备何时掉线，何时上线。设备上的时钟并非和服务上的时钟同步，
因此有可能在某个时刻，设备既没有掉线，也没有在服务上登记。因此必须向前多看一个时
间单位的在线情况，才能判断出设备是否在线。

掉线的判断：

1. 用已注册设备 与 t0 时刻的在线设备求差集得到 Δ0。

2. 用已注册设备 与 t1 时刻的在线设备求差集得到 Δ1。

3. t2 时刻的在线设备与 Δ0 Δ1 一起求交集就是掉线设备。

上线的判断:

1. 用已注册设备 与 t2 时刻的在线设备求差集得到 Δ2。

2. 用已注册设备 与 t1 时刻的在线设备求差集得到 Δ1。

3. t0 时刻的在线设备与 Δ1 Δ2 一起求交集就是上线设备。

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-monitor/src/box_monitor.nim
  proc serve() {.async.} =
    let redis_client = await openAsync(host = "localhost")
    while true:
      let
        t0 = getLocalTime(getTime()) - 1.minutes
        t1 = t0 - 1.minutes
        t2 = t0 - 2.minutes
        enabled_key = "box.enabled"
        enabled = await redis_client.smembers(enabled_key)
        enabled_set = enabled.toSet()
        t0_key = "box.activated." & t0.year.format("04d") & "-" & (ord(t0.month) + 1).format("02d") & "-" & t0.monthday.format("02d") & "." & t0.hour.format("02d") & "." & t0.minute.format("02d")
        t0_set = (await redis_client.smembers(t0_key)).toSet()
        t1_key = "box.activated." & t1.year.format("04d") & "-" & (ord(t1.month) + 1).format("02d") & "-" & t1.monthday.format("02d") & "." & t1.hour.format("02d") & "." & t1.minute.format("02d")
        t1_set = (await redis_client.smembers(t1_key)).toSet()
        t2_key = "box.activated." & t2.year.format("04d") & "-" & (ord(t2.month) + 1).format("02d") & "-" & t2.monthday.format("02d") & "." & t2.hour.format("02d") & "." & t2.minute.format("02d")
        t2_set = (await redis_client.smembers(t2_key)).toSet()
      let
        offline_set = (enabled_set - t0_set) * (enabled_set - t1_set) * t2_set
        online_set = (enabled_set - t2_set) * (enabled_set - t1_set) * t0_set
      if len(online_set) > 0:
        var onlines: seq[string] = @[]
        for id in online_set.items:
          let name = await redis_client.hget("boxes", id)
          onlines.add(name & "(" & id & ")")
        let mail = createMessage("智能柜有" & $len(online_set) & "个柜子上线", onlines.foldl(a & "\n" & b), to)
        await sendmail(mail)
      if len(offline_set) > 0:
        var offlines: seq[string] = @[]
        for id in offline_set.items:
          let name = await redis_client.hget("boxes", id)
          offlines.add(name & "(" & id & ")")
        let mail = createMessage("智能柜有" & $len(offline_set) & "个柜子下线", offlines.foldl(a & "\n" & b), to)
        await sendmail(mail)
      await sleepAsync(60000)
  asyncCheck serve()
  run_forever()
#+end_src

* 支援方法
** sendmail

#+begin_src nim :noweb-ref sendmail
  proc sendmail(msg: Message): Future[void] {.async.} =
    let smtpConn = newAsyncSmtp(useSsl = true, debug = true)
    await smtpConn.connect("smtp.exmail.qq.com", Port 465)
    await smtpConn.auth("sendmail@fengchaohuzhu.com", "Mail1234")
    await smtpConn.sendmail("sendmail@fengchaohuzhu.com", to, $msg)
    await smtpConn.close()
#+end_src
